---
title: "DESeq, EdgeR, Limma, and Voom results to pathways with the **fgsea** package"
author: "Stephen Turner"
date: "`r Sys.Date()`"
output: 
  html_document: 
    # code_folding: show
    fig_height: 8
    fig_width: 8
    warning: FALSE
    message: FALSE
    toc: yes
    toc_float: 
      collapsed: false
      smooth_scroll: false
    # theme: flatly
    # theme: default
    # theme: cerulean
    # theme: journal
    # theme: readable
    # theme: spacelab
    # theme: united
    # theme: cosmo
    # theme: lumen
    # theme: paper
    # theme: sandstone
    # theme: simplex
    # theme: yeti
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, cache=TRUE)
```

```{r gen-airway-results, eval=FALSE}
#This code was used to generate the human airway results:
library(DESeq2);library(airway)
ddsSE <- DESeqDataSet(airway, design = ~ cell + dex)
ddsSE <- DESeq(ddsSE)
res <- results(ddsSE, tidy = TRUE)
readr::write_csv(res, path="data/deseq-results-tidy-human-airway.csv")
### R code from vignette source 'RNA-seqWorkflow.Rnw'
###################################################
### code chunk number 4: readList
###################################################
#an example GMT gene set data derived from MSigDB data
list.files
filename=system.file("extdata/c3.demo.gmt", package = "gage")
demo.gs=readList(filename)
demo.gs[1:3]
#to use these gene sets with gse16873, need to convert the gene symbols
#to Entrez IDs first
data(egSymb)
demo.gs.sym<-lapply(demo.gs, sym2eg)
demo.gs.sym[1:3]

###################################################
### code chunk number 1: synopsis0 (eval = FALSE)
###################################################
## ##step 0: setup (also need to map the reads outside R)
## if (!requireNamespace("BiocManager", quietly=TRUE))
##     install.packages("BiocManager")
## BiocManager::install(c("pathview", "gage", "gageData", "GenomicAlignments",
##             "TxDb.Hsapiens.UCSC.hg19.knownGene"))


###################################################
### code chunk number 2: synopsis1 (eval = FALSE)
###################################################
## ##step 1: read counts
## library(TxDb.Hsapiens.UCSC.hg19.knownGene)
## exByGn <- exonsBy(TxDb.Hsapiens.UCSC.hg19.knownGene, "gene")
## library(GenomicAlignments)
## fls <- list.files("tophat_all/", pattern="bam$", full.names =T)
## bamfls <- BamFileList(fls)
## flag <- scanBamFlag(isSecondaryAlignment=FALSE, isProperPair=TRUE)
## param <- ScanBamParam(flag=flag)
## gnCnt <- summarizeOverlaps(exByGn, bamfls, mode="Union",
##              ignore.strand=TRUE, singleEnd=FALSE, param=param)
## hnrnp.cnts=assay(gnCnt)


###################################################
### code chunk number 3: synopsis2 (eval = FALSE)
###################################################
## ##step 2: preprocessing
## require(gageData) #demo only
## data(hnrnp.cnts) #demo only
## cnts=hnrnp.cnts
## sel.rn=rowSums(cnts) != 0
## cnts=cnts[sel.rn,]
## ##joint workflow with DEseq/edgeR/limma/Cufflinks forks here
## libsizes=colSums(cnts)
## size.factor=libsizes/exp(mean(log(libsizes)))
## cnts.norm=t(t(cnts)/size.factor)
## cnts.norm=log2(cnts.norm+8)


###################################################
### code chunk number 4: synopsis3 (eval = FALSE)
###################################################
## ##step 3: gage
## ##joint workflow with DEseq/edgeR/limma/Cufflinks merges around here
## library(gage)
## ref.idx=5:8
## samp.idx=1:4
## data(kegg.gs)
## cnts.kegg.p <- gage(cnts.norm, gsets = kegg.gs, ref = ref.idx,
##                     samp = samp.idx, compare ="unpaired")


###################################################
### code chunk number 5: synopsis4 (eval = FALSE)
###################################################
## ##step 4: pathview
## cnts.d= cnts.norm[, samp.idx]-rowMeans(cnts.norm[, ref.idx])
## sel <- cnts.kegg.p$greater[, "q.val"] < 0.1 &
##          !is.na(cnts.kegg.p$greater[,"q.val"])
## path.ids <- rownames(cnts.kegg.p$greater)[sel]
## sel.l <- cnts.kegg.p$less[, "q.val"] < 0.1 &
##            !is.na(cnts.kegg.p$less[,"q.val"])
## path.ids.l <- rownames(cnts.kegg.p$less)[sel.l]
## path.ids2 <- substr(c(path.ids, path.ids.l), 1, 8)
## library(pathview)
## pv.out.list <- sapply(path.ids2, function(pid) pathview(
##                       gene.data = cnts.d, pathway.id = pid,
##                       species = "hsa"))


###################################################
### code chunk number 6: start
###################################################
options(width=80)


###################################################
### code chunk number 7: install (eval = FALSE)
###################################################
## if (!requireNamespace("BiocManager", quietly=TRUE))
##     install.packages("BiocManager")
## BiocManager::install(c("pathview", "gage", "gageData", "GenomicAlignments",
##             "TxDb.Hsapiens.UCSC.hg19.knownGene"))


###################################################
### code chunk number 8: readcount (eval = FALSE)
###################################################
## library(TxDb.Hsapiens.UCSC.hg19.knownGene)
## exByGn <- exonsBy(TxDb.Hsapiens.UCSC.hg19.knownGene, "gene")
## library(GenomicAlignments)
## fls <- list.files("tophat_all/", pattern="bam$", full.names =T)
## bamfls <- BamFileList(fls)
## flag <- scanBamFlag(isSecondaryAlignment=FALSE, isProperPair=TRUE)
## param <- ScanBamParam(flag=flag)
## #to run multiple core option: library(parallel); options("mc.cores"=4)
## gnCnt <- summarizeOverlaps(exByGn, bamfls, mode="Union",
##              ignore.strand=TRUE, singleEnd=FALSE, param=param)
## hnrnp.cnts=assay(gnCnt)


###################################################
### code chunk number 9: preprocessing
###################################################
require(gageData)
data(hnrnp.cnts)
cnts=hnrnp.cnts
dim(cnts)
sel.rn=rowSums(cnts) != 0
cnts=cnts[sel.rn,]
dim(cnts)
libsizes=colSums(cnts)
size.factor=libsizes/exp(mean(log(libsizes)))
cnts.norm=t(t(cnts)/size.factor)
range(cnts.norm)
cnts.norm=log2(cnts.norm+8)
range(cnts.norm)
#optional MA plot
pdf("hnrnp.cnts.maplots.pdf", width=8, height=10)
op=par(lwd=2, cex.axis=1.5, cex.lab=1.5, mfrow=c(2,1))
plot((cnts.norm[,6]+cnts.norm[,5])/2, (cnts.norm[,6]-cnts.norm[,5]), 
main="(a) Control vs Control", xlab="mean", ylab="change",
ylim=c(-5,5), xlim=c(0,20), lwd=1)
abline(h=0, lwd=2, col="red", lty="dashed")
plot((cnts.norm[,1]+cnts.norm[,5])/2, (cnts.norm[,1]-cnts.norm[,5]), 
main="(b) Knockdown vs Control", xlab="mean", ylab="change",
ylim=c(-5,5), xlim=c(0,20), lwd=1)
abline(h=0, lwd=2, col="red", lty="dashed")
dev.off()


###################################################
### code chunk number 10: gage
###################################################
library(gage)
ref.idx=5:8
samp.idx=1:4
data(kegg.gs)
#knockdown and control samples are unpaired
cnts.kegg.p <- gage(cnts.norm, gsets = kegg.gs, ref = ref.idx,
                    samp = samp.idx, compare ="unpaired")


###################################################
### code chunk number 11: pathview
###################################################
#differential expression: log2 ratio or fold change, uppaired samples
cnts.d= cnts.norm[, samp.idx]-rowMeans(cnts.norm[, ref.idx])

#up-regulated pathways (top 3) visualized by pathview
sel <- cnts.kegg.p$greater[, "q.val"] < 0.1 &
         !is.na(cnts.kegg.p$greater[,"q.val"])
path.ids <- rownames(cnts.kegg.p$greater)[sel]
path.ids2 <- substr(path.ids, 1, 8)
library(pathview)
pv.out.list <- sapply(path.ids2[1:3], function(pid) pathview(
                      gene.data = cnts.d, pathway.id = pid,
                      species = "hsa"))

#down-regulated pathways  (top 3) visualized by pathview
sel.l <- cnts.kegg.p$less[, "q.val"] < 0.1 &
           !is.na(cnts.kegg.p$less[,"q.val"])
path.ids.l <- rownames(cnts.kegg.p$less)[sel.l]
path.ids.l2 <- substr(path.ids.l, 1, 8)
pv.out.list.l <- sapply(path.ids.l2[1:3], function(pid) pathview(
                      gene.data = cnts.d, pathway.id = pid,
                      species = "hsa"))


###################################################
### code chunk number 12: goanalysis
###################################################
library(gageData)
data(go.sets.hs)
data(go.subs.hs)
lapply(go.subs.hs, head)
#Molecular Function analysis is quicker, hence run as demo
cnts.mf.p <- gage(cnts.norm, gsets = go.sets.hs[go.subs.hs$MF], 
    ref = ref.idx, samp = samp.idx, compare ="unpaired")
#Biological Process analysis takes a few minutes if you try it
#cnts.bp.p <- gage(cnts.norm, gsets = go.sets.hs[go.subs.hs$BP], 
#    ref = ref.idx, samp = samp.idx, compare ="unpaired")


###################################################
### code chunk number 13: goresults
###################################################
for (gs in rownames(cnts.mf.p$less)[1:3]) {
    outname = gsub(" |:|/", "_", substr(gs, 12, 100))
    geneData(genes = go.sets.hs[[gs]], exprs = cnts.norm, ref = ref.idx, 
        samp = samp.idx, outname = outname, txt = T, heatmap = T, 
        limit = 3, scatterplot = T)
}


###################################################
### code chunk number 14: pergenescore
###################################################
cnts.t= apply(cnts.norm, 1, function(x) t.test(x[samp.idx], x[ref.idx],
              alternative = "two.sided", paired = F)$statistic)
cnts.meanfc= rowMeans(cnts.norm[, samp.idx]-cnts.norm[, ref.idx])
range(cnts.t)
range(cnts.meanfc)
cnts.t.kegg.p <- gage(cnts.t, gsets = kegg.gs, ref = NULL, samp = NULL)
cnts.meanfc.kegg.p <- gage(cnts.meanfc, gsets = kegg.gs, ref = NULL, samp = NULL)


###################################################
### code chunk number 15: deseq2
###################################################
library(DESeq2)
grp.idx <- rep(c("knockdown", "control"), each=4)
coldat=DataFrame(grp=factor(grp.idx))
dds <- DESeqDataSetFromMatrix(cnts, colData=coldat, design = ~ grp)
dds <- DESeq(dds)
deseq2.res <- results(dds)
#direction of fc, depends on levels(coldat$grp), the first level
#taken as reference (or control) and the second one as experiment.
deseq2.fc=deseq2.res$log2FoldChange
names(deseq2.fc)=rownames(deseq2.res)
exp.fc=deseq2.fc
out.suffix="deseq2"


###################################################
### code chunk number 16: deseq2
###################################################
require(gage)
data(kegg.gs)
fc.kegg.p <- gage(exp.fc, gsets = kegg.gs, ref = NULL, samp = NULL)
sel <- fc.kegg.p$greater[, "q.val"] < 0.1 &
        !is.na(fc.kegg.p$greater[, "q.val"])
path.ids <- rownames(fc.kegg.p$greater)[sel]
sel.l <- fc.kegg.p$less[, "q.val"] < 0.1 &
           !is.na(fc.kegg.p$less[,"q.val"])
path.ids.l <- rownames(fc.kegg.p$less)[sel.l]
path.ids2 <- substr(c(path.ids, path.ids.l), 1, 8)
require(pathview)
#view first 3 pathways as demo
pv.out.list <- sapply(path.ids2[1:3], function(pid) pathview(
                      gene.data =  exp.fc, pathway.id = pid,
                      species = "hsa", out.suffix=out.suffix))


###################################################
### code chunk number 17: deseq (eval = FALSE)
###################################################
## library(DESeq)
## grp.idx <- rep(c("knockdown", "control"), each=4)
## cds <- newCountDataSet(cnts, grp.idx)
## cds = estimateSizeFactors(cds)
## cds = estimateDispersions(cds)
## #this line takes several minutes
## system.time(
## deseq.res <- nbinomTest(cds, "knockdown", "control")
## )
## deseq.fc=deseq.res$log2FoldChange
## names(deseq.fc)=deseq.res$id
## sum(is.infinite(deseq.fc))
## deseq.fc[deseq.fc>10]=10
## deseq.fc[deseq.fc< -10]=-10
## exp.fc=deseq.fc
## out.suffix="deseq"


###################################################
### code chunk number 18: edger
###################################################
library(edgeR)
grp.idx <- rep(c("knockdown", "control"), each=4)
dgel <- DGEList(counts=cnts, group=factor(grp.idx))
dgel <- calcNormFactors(dgel)
dgel <- estimateCommonDisp(dgel)
dgel <- estimateTagwiseDisp(dgel)
et <- exactTest(dgel)
edger.fc=et$table$logFC
names(edger.fc)=rownames(et$table)
exp.fc=edger.fc
out.suffix="edger"


###################################################
### code chunk number 19: limma
###################################################
library(edgeR)
grp.idx <- rep(c("knockdown", "control"), each=4)
dgel2 <- DGEList(counts=cnts, group=factor(grp.idx))
dgel2 <- calcNormFactors(dgel2)
library(limma)
design <- model.matrix(~grp.idx)
log2.cpm <- voom(dgel2,design)
fit <- lmFit(log2.cpm,design)
fit <- eBayes(fit)
limma.res=topTable(fit,coef=2,n=Inf,sort="p")
limma.fc=limma.res$logFC
names(limma.fc)=limma.res$ID
exp.fc=limma.fc
out.suffix="limma"


###################################################
### code chunk number 20: cufflinks (eval = FALSE)
###################################################
## cuff.res=read.delim(file="gene_exp.diff", sep="\t")
## #notice the column name special character changes. The column used to be
## #cuff.res$log2.fold_change. for older versions of Cufflinks.
## cuff.fc=cuff.res$log2.FPKMy.FPKMx. 
## gnames=cuff.res$gene
## sel=gnames!="-"
## gnames=as.character(gnames[sel])
## cuff.fc=cuff.fc[sel]
## names(cuff.fc)=gnames
## gnames.eg=pathview::id2eg(gnames, category ="symbol")
## sel2=gnames.eg[,2]>""
## cuff.fc=cuff.fc[sel2]
## names(cuff.fc)=gnames.eg[sel2,2]
## range(cuff.fc)
## cuff.fc[cuff.fc>10]=10
## cuff.fc[cuff.fc< -10]=-10
## exp.fc=cuff.fc
## out.suffix="cuff"

```


```{css, echo=FALSE}
pre code, pre, code {
  white-space: pre !important;
  overflow-x: scroll !important;
  word-break: keep-all !important;
  word-wrap: initial !important;
}

blockquote {
  font-size: 90%;
}
```

Here I'll show you how to take results from DESeq and quickly assess for enrichment of pathways using the [fgsea package](http://bioconductor.org/packages/fgsea) for fast preranked gene set enrichment analysis (GSEA).

# FGSEA on DESeq results (human)

First, let's start with a human dataset.

## Load some results from DESeq2

Load some results from DESeq2 (generated using `results(..., tidy=TRUE)`). See the [appendix](#appendix) section at the end for how this data was generated. 

```{r}
library(tidyverse)
res <- read_csv("data/deseq-results-tidy-human-airway.csv")
res
```

Map Ensembl gene IDs to symbol. First create a mapping table.

```{r}
library(org.Hs.eg.db)
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db,
                                    key=res$row, 
                                    columns="SYMBOL",
                                    keytype="ENSEMBL")
ens2symbol <- as_tibble(ens2symbol)
ens2symbol
```

Now join them. 

```{r}
res <- inner_join(res, ens2symbol, by=c("row"="ENSEMBL"))
res
```

Further, all you'll care about later on is the gene symbol and the test statistic. Get just those, and remove the `NA`s. Finally, if you have multiple test statistics for the same symbol, you'll want to deal with that in some way. Here I'm just averaging them. 

```{r}
res2 <- res %>% 
  dplyr::select(SYMBOL, stat) %>% 
  na.omit() %>% 
  distinct() %>% 
  group_by(SYMBOL) %>% 
  summarize(stat=mean(stat))
res2
```

## Using the fgsea package

We're going to use the [fgsea package](http://bioconductor.org/packages/fgsea) for fast preranked gene set enrichment analysis (GSEA). See the [preprint](https://www.biorxiv.org/content/early/2016/06/20/060012) for more details. From the abstract:

> Gene set enrichment analysis is a widely used tool for analyzing gene expression data. However, current implementations are slow due to a large number of required samples for the analysis to have a good statistical power. In this paper we present a novel algorithm, that efficiently reuses one sample multiple times and thus speeds up the analysis. We show that it is possible to make hundreds of thousands permutations in a few minutes, which leads to very accurate p-values. This, in turn, allows applying standard FDR correction procedures, which are more accurate than the ones currently used. 

```{r}
library(fgsea)
```

The `fgsea()` function requires a list of gene sets to check, and a named vector of gene-level statistics, where the names should be the same as the gene names in the pathways list. First, let's create our named vector of test statistics. See `?tibble::deframe` for help here - `deframe()` converts two-column data frames to a named vector or list, using the first column as name and the second column as value.

```{r}
ranks <- deframe(res2)
head(ranks, 20)
```


Let's use the [Hallmark gene set](http://software.broadinstitute.org/gsea/msigdb/collection_details.jsp#H) from MSigDB. Hallmark gene sets summarize and represent specific well-defined biological states or processes and display coherent expression. These gene sets were generated by a computational methodology based on identifying overlaps between gene sets in other MSigDB collections and retaining genes that display coordinate expression. The `gmtPathways()` function will take a GMT file you [downloaded from MSigDB](http://software.broadinstitute.org/gsea/downloads.jsp) and turn it into a list. Each element in the list is a character vector of genes in the pathway.

```{r}
# Load the pathways into a named list
pathways.hallmark <- gmtPathways("data/msigdb/h.all.v6.2.symbols.gmt")

# Look at them all if you want (uncomment)
# pathways.hallmark

# Show the first few pathways, and within those, show only the first few genes. 
pathways.hallmark %>% 
  head() %>% 
  lapply(head)
```

Now, run the fgsea algorithm with 1000 permutations:

```{r}
fgseaRes <- fgsea(pathways=pathways.hallmark, stats=ranks, nperm=1000)
```

Tidy the results:

```{r}
fgseaResTidy <- fgseaRes %>%
  as_tibble() %>%
  arrange(desc(NES))

# Show in a nice table:
fgseaResTidy %>% 
  dplyr::select(-leadingEdge, -ES, -nMoreExtreme) %>% 
  arrange(padj) %>% 
  DT::datatable()
```

Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

```{r}
ggplot(fgseaResTidy, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Hallmark pathways NES from GSEA") + 
  theme_minimal()
```

The [Interferon Alpha Response](http://software.broadinstitute.org/gsea/msigdb/cards/HALLMARK_INTERFERON_ALPHA_RESPONSE.html) gene set was significantly upregulated, consistent with the findings of the [original study](http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0099625). 

What genes are in each of these pathways? First, get a tibble with all the pathways and the genes in them. Continue to join that back to the original data to pull out genes in the pathways. Optionally, filter the list to include only those that are significant, etc. 

```{r}
pathways.hallmark %>% 
  enframe("pathway", "SYMBOL") %>% 
  unnest() %>% 
  inner_join(res, by="SYMBOL")
```

Let's try a different set of pathways. Let's look at KEGG pathways:

```{r}
fgsea(pathways=gmtPathways("data/msigdb/c2.cp.kegg.v6.2.symbols.gmt"), ranks, nperm=1000) %>% 
  as_tibble() %>% 
  arrange(padj)
```

Or miR targets:

```{r}
fgsea(pathways=gmtPathways("data/msigdb/c3.mir.v6.2.symbols.gmt"), ranks, nperm=1000) %>% 
  as_tibble() %>% 
  arrange(padj)
```

Or GO annotations: 

```{r}
fgsea(pathways=gmtPathways("data/msigdb/c5.all.v6.2.symbols.gmt"), ranks, nperm=1000) %>% 
  as_tibble() %>% 
  arrange(padj)
```

# Non-human organisms

If you have a non-human organism, first create a table to map the fly/mouse/worm/etc gene IDs to human symbol:

```{r}
library(biomaRt)
mart <- useDataset("mmusculus_gene_ensembl", mart=useMart("ensembl"))
bm <- getBM(attributes=c("ensembl_gene_id", "hsapiens_homolog_associated_gene_name"), mart=mart) %>%
  distinct() %>%
  as_tibble() %>%
  na_if("") %>% 
  na.omit()
bm
```

